---
title: "DRN.QC.NORMALISATION"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```
##Introduction
This is an R Markdown document for the quality control (QC) of the Illumina EPIC microarray data for a study into Alzheimer's Disease Associated Changes in DNA modifications in DRN post mortem brain tissue.

This study has also included Oxidative Bisulfite (OxBS) sequencing as well Bisulfite (BS) sequencing as to descriminate between 5mC and 5hmc modifications. Therefore there are 2 samples per individual, and if one fails the other sample must also fail.

Samples are not removed after each QC step, but a record is kept of samples which have already failed previous steps and the results of all tests are provided as output.

###Study Information
**Study:** AD-associated DNA modifications in human brainstem (EPI-AD)

**Description:** Case Control/Braak Stage

**QC done by:** Ehsan Pishva

**Study Contact:** Ehsan Pishva(e.pishva@exeter.ac.uk)

**Samples Source:** London Brain Bank()

**Arrays ran by:** GenomeScan

**Location arrays ran:** Genome Scan

**Array used:** Illumina EPIC microarray v1.0

**Date of QC:** `r format(Sys.Date(), format="%d %B %Y")`

**Sample tissue:** DRN Post-Mortem Brain Tissue

##Loading data


```{r loadingdata, include=FALSE}

rm(list=ls())
library(methylumi)
library(wateRmelon)
require(gdata)
library(minfi)
library(ggplot2)
require(gridExtra)
library(Biobase)
library(MLML2R)
```

```{r loadingdata, include=FALSE}

pheno<-read.csv("/mnt/data1/Ehsan/DRN/pheno.drn.all.csv", stringsAsFactors = FALSE, header = TRUE)
#Basename<-paste(pheno$Chip_ID, "_", pheno$Chip_Position)
epicManifest<-read.csv("/mnt/data1/EPIC_reference/MethylationEPIC_v-1-0_B4.csv", skip = 7)

pheno$Chip_ID<-substr(pheno$sentrix_ID,1,12)
Basename<-substr(pheno$sentrix_ID,14,32)
pheno<-cbind(Basename,pheno)

Batch1<-c(200705860090,200772250054,200772260023,200772260051,200793300064,200793300086,200705940020,200772260018,200772260032,200772260053,200793300066,200793820018)

Batch2<-c(200705360009,200772250030,200772250032,200772260017,200793300036,200793300092,200705940021,200772250031,200772260016,200772260040,200793300074,200793300093)

#Since  all idats are not present - loading object saved by Ehsan
setwd("/mnt/data1/Ehsan/DRN/")
load("/mnt/data1/Ehsan/DRN/DRN192_19012017.Rdata") #contains DRN and DRN_PHENO
msetEPIC<-DRN
rm(DRN, DRN_PHENO)
pheno<-pheno[match(colnames(msetEPIC), pheno$sentrix_ID),]

```
Dimention of the dataset generated by the Illumina EPIC array

```{r Dimention.1}
print(dim(msetEPIC))

```

Dimention of the phenotype file

```{r Dimention.2}
print(dim(pheno))
```

##2. Removing bad probes

Removing CrossHydridisingProbes(McCartney)

```{r Dimention.3, include=FALSE}
cross<-read.table("/mnt/data1/EPIC_reference/CrossHydridisingProbes_McCartney.txt", stringsAsFactors = FALSE)
crosslist<-cross[,1]
msetEPIC<-msetEPIC[ ! rownames(msetEPIC) %in% crosslist,]
```

Dimention of the dataset after removing CrossHydridisingProbes(McCartney)

```{r Dimention.4}
print(dim(msetEPIC))

```

Remove probes with SNPs

```{r Dimention.5, include=FALSE}
############################################################
##REMOVE PROBES with SNPs
############################################################
snpProbes<-read.table("/mnt/data1/EPIC_reference/SNPProbes_McCartney.txt", stringsAsFactors = FALSE, header = TRUE)
snpProbes<-snpProbes[which(snpProbes$EUR_AF >= 0.05 & snpProbes$EUR_AF <= 0.95),]
SNPlist<-snpProbes[,1]
msetEPIC <-msetEPIC[! rownames(msetEPIC) %in% SNPlist,]

```

Dimention of the dataset after removing probes with SNPs(Illumina)

```{r Dimention.6}
print(dim(msetEPIC))

```

REMOVE bad probes

```{r Dimention.7, include=FALSE}
##REMOVE bad probes
badProbes<-read.csv("/mnt/data1/EPIC_reference/EPICArrayProbesToFilter.csv", stringsAsFactors = FALSE, header = TRUE)
badlist<-badProbes[,1]
msetEPIC<- msetEPIC[ ! rownames(msetEPIC) %in% badlist,]
```

Dimention of the dataset after removing badProbes(Illumina)

```{r Dimention.8}
print(dim(msetEPIC)) 

```

Test if the samples in the arrays are in the same order as phnotype files

```{r Dimention.9}
print(identical(pheno$sentrix_ID, colnames(msetEPIC)))

```

```{r createQCmetrics, include=FALSE}
#SamplesFail will be our boolean record of which samples have already failed
SamplesFail<-rep(FALSE, nrow(pheno))
#Entries will be changed to TRUE as samples fail 

Stepsummary<-as.data.frame(matrix(ncol=0, nrow=3))
rownames(Stepsummary)<-c("Samples Failed", "Paired Samples Failed", "Total Failed")

Key<-rep("", nrow(pheno))
Key[grep("-BS-", pheno$Sample_Name)]<-"BS"
Key[grep("-oxBS-", pheno$Sample_Name)]<-"OxBS"
Key[which(pheno$BrainBankID=="" & Key=="BS")]<-"BS Control"
Key[which(pheno$BrainBankID=="" & Key=="OxBS")]<-"OxBS Control"

Batch<-rep(0, nrow(pheno))
Batch[pheno$Chip_ID %in% Batch1]<-1
Batch[pheno$Chip_ID %in% Batch2]<-2

#QC metrics will be columns appended to a copy of the pheno file
QCmetrics<-cbind(pheno, Key, Batch)
```

The phenotype file containing the sample information was loaded into R. Then the methylation data for the `r nrow(pheno)` samples were loaded into a methylumiset.

We have 2 samples each from `r sum(Key=="BS")` individuals, ran with `r sum(Key=="Control")` control samples.

##1. Check Samples Match
For this QC it is important to first check that all pairs of BS and oxBS samples are from the same individual. This is vital for later analyses which require samples to be matched and for later QC steps as we can fail samples based on the performace of their pair.

On the EPIC array there are 59 SNP probes, which can be used to check the identity of genotyped samples and to find genetically identical samples (such as samples from the same individual, MZ twins or samples duplicated by error).  

We can calculate the correlation in methylation on these 59 SNP probes between all samples. We expect correlations between samples form the same individual to be high (approximately > 0.8) and correlations between unrelated samples to be low (approximately < 0.8).

```{r checkpaircor, include=F}
#Finds SNP betas
betas<-betas(msetEPIC)
betas.rs<-betas[grep("rs", rownames(betas)),]

#Calculates all SNP correlations, and removed correlations between a sample and itself
snpCor<-cor(betas.rs, use="complete.obs")
for(i in 1:ncol(betas.rs)){
	snpCor[i,i]<-NA
}

#PairCor records the cor for each sample to add to QCmetrics
IDs<-unique(pheno$BrainBankID)
PairCor<-rep(NA, nrow(pheno))

for(i in 1:length(IDs)){
  pair<-which(pheno$BrainBankID==IDs[i])
  if(length(pair)==2 & IDs[i]!=""){
    PairCor[pair]<-snpCor[pair[1],pair[2]]
  }
}

#UnrelatedCor is a new version of the snpCor matrix with paired correlations removed
UnrelatedCor<-snpCor
for(i in 1:length(IDs)){
  pair<-which(pheno$BrainBankID==IDs[i])
  UnrelatedCor[pair,pair]<-NA
}

#MaxUnrelatedCor records the maximum correlation for each row (sample)
MaxUnrelatedCor<-rep(NA, nrow(pheno))
for (j in 1:nrow(pheno)){
  MaxUnrelatedCor[j]<-max(UnrelatedCor[j,], na.rm=T)
}
```


```{r plotpaircors, echo=F}
par(mfrow=c(1,2))

hist(PairCor, xlab="Correlation Coefficient", main = "Correlation in Sample Pairs", col="skyblue", cex.main=0.8)

hist(MaxUnrelatedCor, main="Maximum Correlation in Unpaired Samples", xlab="Correlation Coefficient", col="skyblue", cex.main=0.8)
par(mfrow=c(1,1),pin = c(6, 2.5))
plot(hclust(dist(snpCor)), las=2, main="Hierarchial clustering 59RS SNP probes", cex=0.2)

```

The histograms show that `r sum(PairCor<0.8, na.rm=T)` samples have a correlation < 0.8 with their paired sample and `r sum(MaxUnrelatedCor>0.8)` samples have a correlation > 0.8 with any other sample. 

Therefore all samples are correctly paired and 0 fail this step.

```{r updateQCmetrics1, include=FALSE}
QCmetrics<-cbind(QCmetrics, PairCor, MaxUnrelatedCor)

Step1<-c(0,0, sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step1)
```

```{r Stepsummary1}
print(Stepsummary)
```

## Removing bad Samples
The company recommended that 4 samples should be dropped due to low performance. Any paired BS/oxBS samples are also dropped.

```{r updateQCmetrics2, include=FALSE}
CompanyDrop<-rep("", nrow(pheno))

CompanyDrop[which(pheno$Basename=="200772260017_R01C01" | pheno$Basename=="200772260017_R02C01" |pheno$Basename=="200772260017_R04C01" |pheno$Basename=="200793300066_R06C01")]<-"Dropped"

for(sample in which(CompanyDrop=="Dropped")){
  individual<-pheno$BrainBankID[sample]
  paired<-which(pheno$BrainBankID==individual & c(1:nrow(pheno))!= sample)
  if(CompanyDrop[paired]!="Dropped"){
    CompanyDrop[paired]<-"Pair Dropped"
  }
}

SamplesFail[which(CompanyDrop!="")]<-TRUE
QCmetrics<-cbind(QCmetrics, CompanyDrop)

Step2<-c(sum(CompanyDrop=="Dropped"),sum(CompanyDrop=="Pair Dropped"),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step2)
drop.2<-c(QCmetrics[grep("Dropped",QCmetrics$CompanyDrop),]$sentrix_ID)

```

```{r Stepsummary2}
print(Stepsummary)
print(drop.2)
```

##2. Signal Intensities
The median methylated signal intensity and unmethylated signal intensity for each sample is calculcated.

```{r medianintensities, include=FALSE}
m_intensities<-methylated(msetEPIC)
u_intensities<-unmethylated(msetEPIC)
M.median<-apply(m_intensities, 2, median)
U.median<-apply(u_intensities, 2, median)
QCmetrics<-cbind(QCmetrics,M.median, U.median)
```

A histogram and scatter plot of the resulting data are plotted to visualise the data quality.

```{r plotintensities, echo=FALSE}
plotfactor<-as.factor(QCmetrics$Key)

par(mfrow = c(1,2))
hist(M.median, xlab = "Median M intensity", main="Histogram of Median Methylated Intensities", cex.main=0.7)
hist(U.median, xlab = "Median U intensity", main="Histogram of Median Unmethylated Intensities", cex.main=0.7)
par(mfrow = c(1,1))
plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Scatter plot of Signal Intensities", xlim=c(0,4000),ylim=c(0,4000))

#Overlaying the control points again as they were a bit hidden
points(M.median[Key=="BS Control"],U.median[Key=="BS Control"], col=rainbow(4)[2], pch=16)
points(M.median[Key==""],U.median[Key==""], col=rainbow(4)[4], pch=16)

legend("topleft", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 16, cex=0.6)
```

The BS and oxBS samples are separated as we might expect, and the control samples are within the appropriate cluster. 

To look for batch effects we can colour the samples by methylation chip and methylation plate.

```{r batcheffects, echo=FALSE}
plotfactor<-as.factor(pheno$Chip_ID)

plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Signal Intensities Coloured by Methylation Chip", xlim=c(0,4000),ylim=c(0,4000))
legend("topleft", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 16, cex=0.5)

plotfactor<-as.factor(QCmetrics$Batch)

plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col = rainbow(nlevels(plotfactor))[factor(plotfactor)], main="Signal Intensities Coloured by Methylation Plate", xlim=c(0,4000),ylim=c(0,4000))
legend("topleft", levels(factor(plotfactor)), col = rainbow(nlevels(plotfactor)), pch = 16)
```

We can see that any batch effects are mild.

To further investigate the plates we can plot heatmaps of the intensities across the plates.

```{r intensityheatmap, echo=FALSE}
plates<-c(1,2)
QCmetrics$Chip_Position<-factor(QCmetrics$Chip_Position)
QCmetrics$Chip_ID<-factor(QCmetrics$Chip_ID, levels=rev(unique(QCmetrics$Chip_ID))) #keeps the levels of the factor in current order rather than sorting numerically/alphabetically, also reverses this order as heatmaps plot bottom to top

#extract the legend (using a function found online)
g_legend<-function(a.gplot){
    tmp <- ggplot_gtable(ggplot_build(a.gplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

for(plate in plates){
  samples<-QCmetrics[which(QCmetrics$Batch == plate),]
  control<-samples[grep("Control", samples$Key),]

  plateHeatmap <- ggplot(data=samples, aes(x=Chip_Position, y=Chip_ID)) +
    scale_fill_gradientn(colours=colorRamps::matlab.like(100), limits=c(min(QCmetrics$U.median, QCmetrics$M.median),max(QCmetrics$U.median, QCmetrics$M.median))) +
    labs(x="", y="") +
    theme_minimal() + 
    coord_equal() +
    theme(plot.title = element_text(hjust = 0.5), axis.text.x = element_text(angle = 90, hjust=1))
  
  plot1 <- plateHeatmap +
    ggtitle("Median Methylated Intensity") +
    geom_tile(aes(fill=M.median), colour = "white") +
    geom_point(data=control, aes(x=Chip_Position, y=Chip_ID)) +
    theme(legend.position = "none")
  
  plot2 <- plateHeatmap +
    ggtitle("Median Unmethylated Intensity") +
    geom_tile(aes(fill=U.median), colour = "white") +
    geom_point(data=control, aes(x=Chip_Position, y=Chip_ID)) +
    theme(legend.position = "none")
  
  legendplot<-plateHeatmap + 
    geom_tile(aes(fill=U.median), colour = "white") +
    labs(fill="Intensity", alpha="Control") +
    geom_point(data=control, aes(x=Chip_Position, y=Chip_ID, alpha=rep(TRUE,nrow(control)))) +
    scale_alpha_manual(values=c(1,1,1)) + 
    guides(alpha = guide_legend(override.aes = list(colour="black", pch=16)))
    
  legend<-g_legend(legendplot)
  
  grid.arrange(plot1, plot2, legend, ncol=3, widths=c(3/7, 3/7, 1/7), top=paste("Plate", plate))
}
```

To filter blood samples, we normally remove samples which have both signal intensities less than 2000. 

```{r}
lowintensitysamples<-which(M.median < 1500 & U.median < 1500)
```

```{r scatter2000,echo=FALSE}
Intensity<-rep("OK", nrow(pheno))
Intensity[lowintensitysamples] <-"LowIntensity"

plotfactor<-as.factor(Intensity)

plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col=rainbow(2)[factor(plotfactor)])
abline(v = 1500, col = "red")
abline(h = 1500, col = "red")
legend("topleft", levels(factor(plotfactor)), pch = 16, col = rainbow(2))
```

With this threshold `r length(lowintensitysamples)` samples would fail the QC. We can reduce the threshold to 1500 and plot again.

```{r}
lowintensitysamples<-which(M.median < 1000 & U.median < 1000)
```

```{r scatter1500, echo=FALSE}
Intensity<-rep("OK", nrow(pheno))
Intensity[lowintensitysamples] <-"LowIntensity"

plotfactor<-as.factor(Intensity)

plot(M.median, U.median, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", col=rainbow(2)[factor(plotfactor)])
abline(v = 1000, col = "red")
abline(h = 1000, col = "red")
legend("topleft", levels(factor(plotfactor)), pch = 16, col = rainbow(2))
```

With this threshold only `r length(lowintensitysamples)` samples fail the QC. However we should be cautious about reducing the thresholds too far.

```{r updateQCmetrics3, include=FALSE}
Intensity<-rep("", nrow(pheno))
Intensity[lowintensitysamples] <-"Low Intensity"

for(sample in which(Intensity=="Low Intensity")){
  individual<-pheno$BrainBankID[sample]
  paired<-which(pheno$BrainBankID==individual & c(1:nrow(pheno))!= sample)
  if(Intensity[paired]!="Low Intensity"){
    Intensity[paired]<-"Pair Low Intensity"
  }
}

SamplesFail[which(Intensity!="")]<-TRUE
QCmetrics<-cbind(QCmetrics, Intensity)

Step3<-c(sum(Intensity=="Low Intensity"),sum(Intensity=="Pair Low Intensity"),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step3)
drop.3<-c(QCmetrics[grep("Intensity",QCmetrics$Intensity),]$sentrix_ID)

```

```{r Stepsummary3}
print(Stepsummary)
print(drop.3)
```

##4. Bisulphite Conversion
A bisulphite conversion statistic for each sample was calculated, and a histogram of the results plotted.

```{r bisulphiteconversion, echo=FALSE}
BS_Stat<-bscon(msetEPIC)
par(mfrow=c(1,2))
hist(BS_Stat[which(Key=="BS")], xlab = "Median % BS conversion", main = "Histogram of BS Converstion - BS Samples", cex.main=0.7, xlim=c(20, 100), breaks=seq(20,100,10))
abline(v=80, col="red")
hist(BS_Stat[which(Key=="OxBS")], xlab = "Median % BS conversion", main = "Histogram of BS Converstion - oxBS Samples", cex.main=0.7,  xlim=c(20, 100), breaks=seq(20,100,10))
abline(v=80, col="red")
```

This shows the conversion statistics were generally high, but perfomed much better on the BS than oxBS samples. This is may be due to the probes selected for the test being optimised for BS samples only. Therefore we will only fail the `r length(which(BS_Stat<80 & QCmetrics$Key == "BS"))` BS samples with a conversion < 80%.

```{r updateQCmetrics4, include=FALSE}
BS_Fail<-rep("", nrow(pheno))
BS_Fail[which(BS_Stat<80 & QCmetrics$Key == "BS")] <-"Low BS"

for(sample in which(BS_Fail=="Low BS")){
  individual<-pheno$BrainBankID[sample]
  paired<-which(pheno$BrainBankID==individual & c(1:nrow(pheno))!= sample)
  if(BS_Fail[paired]!="Low BS"){
    BS_Fail[paired]<-"Pair Low BS"
  }
}

SamplesFail[which(BS_Fail!="")]<-TRUE
QCmetrics<-cbind(QCmetrics, BS_Stat, BS_Fail)

Step4<-c(sum(BS_Fail=="Low BS"),sum(BS_Fail=="Pair Low BS"),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step4)
drop.4<-c(QCmetrics[grep("BS",QCmetrics$BS_Fail),]$sentrix_ID)
```

```{r Stepsummary4}
print(Stepsummary)
print(drop.4)
```

##5. Check Sex
A principle component analysis of the methylation data can be used to predict the sex of the samples.

The MDS are calculated, and the two which correlate most with sex are found. These can be used to generate a scatter plot where the sexes are clearly separated.

```{r definegenderfunction, include=FALSE}
BS<-which(pheno$Pool_ID == "BS")
oxBS<-which(pheno$Pool_ID == "oxBS")

betas.BS <-betas[,BS]
betas.oxBS <-betas[,oxBS]
pheno.BS<-pheno[BS,]
pheno.oxBS<-pheno[oxBS,]

epicManifest<-epicManifest[match(rownames(betas.BS), epicManifest$Name),]
###TESTING THE SEX LABELS and PROFILE BASED ON BS DATA
pheno.BS$Gender<- as.factor(pheno.BS$Gender)
pheno.oxBS$Gender<- as.factor(pheno.oxBS$Gender)

l.bs<-pheno.BS$BrainBankID
l.ox<-pheno.oxBS$BrainBankID

epicManifest.x<-epicManifest[which(epicManifest$CHR == "X"),]
epicManifest.y<-epicManifest[which(epicManifest$CHR == "Y"),]

###TESTING THE SEX LABELS and PROFILE BASED ON BS DATA
betasBS.x<-betas.BS[as.character(epicManifest.x$IlmnID),]
fit.x.bs<-data.frame(cmdscale(dist(t(betasBS.x)),2))
betasBS.y<-betas.BS[as.character(epicManifest.y$IlmnID),]
fit.y.bs<-data.frame(cmdscale(dist(t(betasBS.y)),2))

###TESTING THE SEX LABELS and PROFILE BASED ON oxBS DATA
betasoxBS.x<-betas.oxBS[as.character(epicManifest.x$IlmnID),]
fit.x.ox<-data.frame(cmdscale(dist(t(betasoxBS.x)),2))
betasoxBS.y<-betas.oxBS[as.character(epicManifest.y$IlmnID),]
fit.y.ox<-data.frame(cmdscale(dist(t(betasoxBS.y)),2))

sex_palette.bs<-cbind(c("0", "1"), c("blue", "magenta"))
sex_col.bs<-sex_palette.bs[match(pheno.BS$Gender, sex_palette.bs[,1]),2]

sex_palette.ox<-cbind(c("0", "1"), c("blue", "magenta"))
sex_col.ox<-sex_palette.ox[match(pheno.oxBS$Gender, sex_palette.ox[,1]),2]
```

Gender match using BS data

```{r gendermatchBS, echo=FALSE}
par(mfrow = c(1,2),pin = c(2.5, 2.5))
plot(fit.x.bs[,1], fit.x.bs[,2], xlab = "MDS Co-ordinate 1", ylab = "MDS Co-ordinate 2", pch = 20, col = sex_col.bs, main = "X Chromosome")
legend("bottomright", horiz = TRUE, c("M", "F"), col = c("blue", "magenta"), pch = 20)
text(fit.x.bs[,1], fit.x.bs[,2],labels=l.bs, cex= 0.3, pos=2)

plot(fit.y.bs[,1], fit.y.bs[,2], xlab = "MDS Co-ordinate 1", ylab = "MDS Co-ordinate 2", pch = 20, col = sex_col.bs, main = "Y Chromosome")
legend("bottomright", horiz = TRUE, c("M", "F"), col = c("blue", "magenta"), pch = 20)
text(fit.y.bs[,1], fit.y.bs[,2],labels=l.bs, cex= 0.3, pos=2)

```

Gender match using oxBS data

```{r gendermatchoxBS, echo=FALSE}
par(mfrow = c(1,2),pin = c(2.5, 2.5))
plot(fit.x.ox[,1], fit.x.ox[,2], xlab = "MDS Co-ordinate 1", ylab = "MDS Co-ordinate 2", pch = 20, col = sex_col.ox, main = "X Chromosome")
legend("bottomright", horiz = TRUE, c("M", "F"), col = c("blue", "magenta"), pch = 20)
text(fit.x.ox[,1], fit.x.ox[,2],labels=l.ox, cex= 0.3, pos=2)

plot(fit.y.ox[,1], fit.y.ox[,2], xlab = "MDS Co-ordinate 1", ylab = "MDS Co-ordinate 2", pch = 20, col = sex_col.ox, main = "Y Chromosome")
legend("topright", horiz = TRUE, c("M", "F"), col = c("blue", "magenta"), pch = 20)
text(fit.y.ox[,1], fit.y.ox[,2],labels=l.ox, cex= 0.3, pos=2)




Step5<-c(0,0,sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step5)
```

```{r Stepsummary5}
print(Stepsummary)
```



##6. P-Filter
The pfilter function in the wateRmelon package filters data sets based on beadcounts and detection p-values.

###Beadcounts
If the percentage of samples with a beadcount less than 3 is greater than 5% for any probe, the probe is removed.

###Detection p-values
If the percentage of probes with a detection p-value less than 0.05 is greater than 1% for any sample, the sample is removed.

Similarly, if the percentage of samples with a detection p-value less than 0.05 is greater than 1% for any probe, the probe is removed.

```{r pfilterdefault}
msetEPIC.pf <- pfilter(msetEPIC)
```
```{r updateQCmetrics6, include=FALSE}
#remove the probes that failed the pfilter
msetEPIC<-msetEPIC[rownames(betas(msetEPIC)) %in% rownames(betas(msetEPIC.pf)),]

#mark samples that fail the pfilter
pFilterPass<-rep("", nrow(pheno))
pFilterPass[!colnames(betas(msetEPIC)) %in% colnames(betas(msetEPIC.pf))]<-"Fail"

for(sample in which(pFilterPass=="Fail")){
  individual<-pheno$BrainBankID[sample]
  paired<-which(pheno$BrainBankID==individual & c(1:nrow(pheno))!= sample)
  if(pFilterPass[paired]!="Fail"){
    pFilterPass[paired]<-"Pair Fail"
  }
}

SamplesFail[which(pFilterPass!="")]<-TRUE
QCmetrics<-cbind(QCmetrics, pFilterPass)

Step6<-c(sum(pFilterPass=="Fail"),sum(pFilterPass=="Pair Fail"),sum(SamplesFail))
Stepsummary<-cbind(Stepsummary,Step6)

drop.6<-c(QCmetrics[grep("Fail",QCmetrics$pFilterPass),]$sentrix_ID,
          QCmetrics[grep("Control",QCmetrics$Key),]$sentrix_ID)


QCmetrics.1<-QCmetrics[-which(QCmetrics$sentrix_ID %in% drop.2),]
QCmetrics.2<-QCmetrics.1[-which(QCmetrics.1$sentrix_ID %in% drop.3),]
QCmetrics.3<-QCmetrics.2[-which(QCmetrics.2$sentrix_ID %in% drop.4),]
QCmetrics.4<-QCmetrics.3[-which(QCmetrics.3$sentrix_ID %in% drop.6),]

PassedQC<-QCmetrics.4$sentrix_ID

msetEPIC.pfiltered<-msetEPIC.pf[,which(colnames(msetEPIC.pf) %in% PassedQC)] 
pheno.filtered<-pheno[which(pheno$sentrix_ID %in% PassedQC),]

```


```{r Stepsummary6}
print(Stepsummary)
print(identical(colnames(msetEPIC.pfiltered),pheno.filtered$sentrix_ID))
```


```{r Normalisation1, include=FALSE}
data.dasen<-dasen(msetEPIC.pfiltered)
BS<-which(pheno.filtered$Pool_ID == "BS")
oxBS<-which(pheno.filtered$Pool_ID == "oxBS")

dasen.BS<-data.dasen[,BS]
dasen.oxBS<-data.dasen[,oxBS]
pheno.BS<-pheno.filtered[BS,]
pheno.oxBS<-pheno.filtered[oxBS,]

pheno.BS$id.number<-substr(pheno.BS$Sample_Name,13,15)
pheno.oxBS$id.number<-substr(pheno.oxBS$Sample_Name,15,17)

colnames(dasen.BS)<-pheno.BS$id.number
colnames(dasen.oxBS)<-pheno.oxBS$id.number


betas.BS<-betas(dasen.BS)

# Methylated signals from the BS and oxBS arrays
methBS <- methylated(dasen.BS)
methOxBS <- methylated(dasen.oxBS)
# Unmethylated signals from the BS and oxBS arrays
unmethBS <- unmethylated(dasen.BS)
unmethOxBS <- unmethylated(dasen.oxBS)

setwd("/mnt/data1/Ehsan/DRN/")
load("ML.drn.79.Rdata")
#save(methBS,unmethBS,unmethOxBS,methOxBS, pheno.BS, pheno.oxBS, file="ML.drn.79.Rdata")
#save(betas.BS, pheno.BS, file="normalised.betas.BS.drn.79.Rdata")

```


```{r Normalisation2}
print(identical(colnames(dasen.BS), colnames(dasen.oxBS)))

```

```{r medianintensities, include=FALSE}
M.median.drn<-apply(methBS, 2, median)
U.median.drn<-apply(unmethBS, 2, median)
```



```{r plotintensities, echo=FALSE}

par(mfrow = c(1,2))
hist(M.median.drn, xlab = "Median M intensity", main="Histogram of Median Methylated Intensities", cex.main=0.7)
hist(U.median.drn, xlab = "Median U intensity", main="Histogram of Median Unmethylated Intensities", cex.main=0.7)
par(mfrow = c(1,1))
plot(M.median.drn, U.median.drn, pch = 16, xlab = "Median M intensity", ylab = "Median U intensity", main="Scatter plot of Signal Intensities", xlim=c(1868,1873),ylim=c(1816,1818), col="blue")                                                                                                                           
```






```{r Normalisation3}
load(file="ML.drn.79.Rdata")
DRN.ML <- MLML(T = methBS , U = unmethBS, L = unmethOxBS, M = methOxBS, exact=TRUE)
U<-data.frame(DRN.ML$C)
mC<-data.frame(DRN.ML$mC)
hmC<-data.frame(DRN.ML$hmC)
betas.BS<-betas(dasen.BS)
#save(U, mC, hmC, pheno.BS, file="drn.ML.readyforEWAS.79.Rdata")
```


```{r ML.NORMAISATION, echo=FALSE}
par(mfrow = c(1,3))
plot(density(as.matrix(U), na.rm = TRUE), main = "U", xlim = c(0, 1), ylim = c(0, 10), col = "black", lty = 1, lwd = 2)
plot(density(as.matrix(mC),na.rm = TRUE), main = "mC", xlim = c(0, 1), ylim = c(0, 10), col = "red", lty = 1, lwd = 2)
plot(density(as.matrix(hmC),na.rm = TRUE), main = "hmC",xlim = c(0, 1), ylim = c(0, 150), col = "green", lty = 1, lwd = 2)
```


```{r Normalisationh, echo=FALSE}
plot(rowMeans(mC)~rowMeans(betas.BS), col="green")
abline(lm(rowMeans(mC)~rowMeans(betas.BS)))
```
Correlation between 5mC values estimated by ML method and Normalised data generated by oxBS arrys

```{r Normalisation6}
cor.test(rowMeans(mC),rowMeans(betas.BS))
```



